{
    "collab_server" : "",
    "contents" : "##---------------------------------------------------------------------##\n## --This program is written by Wenbao Yu for implementing GMAP -------##\n## --This file contains all the source codes\n##---------------------------------------------------------------------##\n\n# call upstream window counts of class1\nup_stat <- function(x, pp, d = 50){\n  pairx = (x - d + 1) : x\n  if(x < d) pairx = 1:x\n  if(x < 5) pairx = 1 : 5   # use 4 as a buffer\n  num_class1 = sum(pp[pairx, pairx])\n  tnum = (length(pairx))^2\n  return(c(num_class1, tnum))\n}\nup_stat = cmpfun(up_stat)\n\n\n# call downstream window counts of class1\ndown_stat <- function(x, pp, d = 50){\n  pairx = x:(x + d - 1)\n  if(x > nrow(pp) - d + 1) pairx = (nrow(pp) - d + 1) : nrow(pp)\n  if(x > nrow(pp) - 5) pairx = (x-4) : nrow(pp)\n\n  num_class1 = sum(pp[pairx, pairx])\n  tnum = (length(pairx))^2\n  return(c(num_class1,  tnum))\n}\ndown_stat = cmpfun(down_stat)\n\n\n# call counts of class1 beween the upwindow and downwindow\nbtw_stat <- function(x, pp, d = 50){\n  pairx1 = (x - d + 1) : x\n  pairx2 = x : (x + d - 1)\n\n  if(x < d) pairx1 = 1:x\n  if(x < 5) pairx1 = 1 : 5\n\n  if(x > nrow(pp) - d + 1) pairx2 = (nrow(pp) - d + 1) : nrow(pp)\n  if(x > nrow(pp) - 5) pairx2 = (x-4) : nrow(pp)\n\n  num_class1 = sum(pp[pairx1, pairx2]) + sum(pp[pairx2, pairx1])\n  tnum = 2 * length(pairx1) * length(pairx2)\n  return(c(num_class1,  tnum))\n}\nbtw_stat = cmpfun(btw_stat)\n\n\n## calculate within-between test stat\ncal_stat <- function(pp, d = 50){\n  bpos = 1:nrow(pp)\n  ustat = lapply(bpos, up_stat,  pp=pp, d = d)\n  dstat = lapply(bpos, down_stat, pp=pp,  d = d)\n  bstat = lapply(bpos, btw_stat, pp=pp,  d = d)\n\n  n_up = sapply(ustat, function(x) x[2])\n  n_btw = sapply(bstat, function(x) x[2])\n  n_down = sapply(dstat, function(x) x[2])\n\n  prop_up = sapply(ustat, function(x) x[1]/x[2])\n  prop_btw = sapply(bstat, function(x) x[1]/x[2])\n  prop_down = sapply(dstat, function(x) x[1]/x[2])\n\n  prop_up[n_up == 0] = 0L\n  prop_down[n_down == 0] = 0L\n  prop_btw[n_btw == 0] = 0L\n\n  # for testing difference between up and down\n  p0 = (n_down * prop_down + n_up * prop_up)/(n_up + n_down)\n  serror = sqrt(p0 * (1-p0) * (1/(n_up) + 1/n_down))\n  test = (prop_up - prop_down)/serror\n  test[serror == 0] = 100L\n\n  stat_up = pmax(0, test)\n  stat_down = pmax(0, -test)\n\n\n  # testing up+down > between\n  n = length(bpos)\n  p0 = (n_down * prop_down + n_up * prop_up + n_btw * prop_btw) / (n_down + n_btw + n_up)\n  serror = sqrt(p0 * (1-p0) * (1/(n_up + n_down) + 1/n_btw))\n  prop_within = (n_down * prop_down + n_up * prop_up)/(n_up + n_down)\n  stat_wb = (prop_within - prop_btw)/serror\n  stat_wb[serror == 0] = 0L\n\n\n  ## proportion fold change between intra and inter domains\n  fc1 = prop_up/prop_btw\n  fc2 = prop_down/prop_btw\n  fc1[is.infinite(fc1)] = 1000\n  fc2[is.infinite(fc2)] = 1000\n\n  fc1[is.na(fc1)] = 1\n  fc2[is.na(fc2)] = 1\n\n  pr_fc_wb = pmax(fc1, fc2)\n\n\n  ## proportion fold change between up and down domains\n  pr_fc_ud = pmax(prop_up/prop_down, prop_down/prop_up)\n\n  pr_fc_ud[is.infinite(pr_fc_ud)] = 1000\n  pr_fc_ud[is.na(pr_fc_ud)] = 1\n\n\n\n  return(list('up' = round(stat_up, 2), 'down' = round(stat_down,2),\n              'wb' = round(stat_wb, 2),\n              'pr_fc_wb' = round(pr_fc_wb, 2), 'pr_fc_ud' = round(pr_fc_ud,2)))\n\n}\ncal_stat = cmpfun(cal_stat)\n\n\n\n## find local peaks for a given vector\n## better version\nlocalMaxima <- function(x, pr_fc_wb, thr = 2, fcthr = 0.9, dp = 10) {\n  #y = which(diff(sign(diff(x))) == -2) + 1\n\n  # smmothing using sliding window before search local peaks -- not used\n  x = runmean(x, 5)\n\n  x = round(x, 1)\n  y = extrema(x)$maxindex[, 1]\n  xy = x[y]\n  y = y[xy >= thr]  ## screening by t1\n\n  pr_fc_wb = round(runmean(pr_fc_wb, 5), 2)\n\n\n  xy = pr_fc_wb[y]  ## further screening some peaks with small wb-proportion fold change\n  y = y[xy >= quantile(pr_fc_wb, fcthr)]\n\n  if(length(y) == 0) return(NULL)\n\n  # remove peaks that are close\n  if(!is.null(y)) y = combPeaks(y, x, dp)\n\n\n  y = y[y >= 6]\n  y = y[y <= (length(x) - 6)]\n\n  return(y)\n}\nlocalMaxima = cmpfun(localMaxima)\n\n\n# define fcthr,thr locally\nlocalMaxima1 <- function(x,  pr_fc_wb, thr = 0.75, fcthr = 0.9, dp = 10) {\n  # smmothing using sliding window before search local peaks\n  x = runmean(x, 5)\n  x = round(x, 1)\n\n  local_t1_quantile <- function(ly){\n    ll = max(ly - 500, 1)\n    rr = min(ly + 500, length(x))\n    return(quantile(x[ll : rr], thr))\n  }\n\n  local_t1thr = quantile(x, thr)\n\n  y = extrema(x)$maxindex[, 1]\n  xy = x[y]\n\n  if(length(x) >= 1000) local_t1thr = sapply(y, local_t1_quantile)\n\n\n  y = y[xy >= local_t1thr]  ## screening by t1\n\n  pr_fc_wb = round(runmean(pr_fc_wb, 5), 2)\n\n  ## locally screening further, using fold change\n  xy_fc = pr_fc_wb[y]\n  local_fcthr = quantile(pr_fc_wb, fcthr)\n\n  local_fc_quantile <- function(ly){\n    ll = max(ly - 500, 1)\n    rr = min(ly + 500, length(x))\n    return(quantile(pr_fc_wb[ll : rr], fcthr))\n  }\n\n  if(length(x) >= 1000) local_fcthr = sapply(y, local_fc_quantile)\n  y = y[xy_fc >= local_fcthr]\n\n  if(length(y) == 0) return(NULL)\n\n  # remove peaks that are close\n  if(!is.null(y)) y = combPeaks(y, x, dp)\n\n\n  y = y[y >= 6]\n  y = y[y <= (length(x) - 6)]\n\n  return(y)\n}\nlocalMaxima1 = cmpfun(localMaxima1)\n\n\n## define tad by gmap given peaks and statistics\ndef_tad_gmap <- function(wb_peaks, stat_up, stat_down, nn, thr = 2, pr_fc_ud){\n  s1 = stat_up[wb_peaks]\n  s2 = stat_down[wb_peaks]\n  fc = pr_fc_ud[wb_peaks]\n\n  len = length(wb_peaks)\n  signs = rep(0, len)\n  pr_fc_ud = pr_fc_ud[wb_peaks]\n  ind1 = which(s1 > thr & fc > quantile(pr_fc_ud, 0.95))\n  ind2 = which(s2 > thr & fc > quantile(pr_fc_ud, 0.95))\n  if(length(ind1) > 0) signs[ind1] = 1\n  if(length(ind2) > 0) signs[ind2] = -1\n\n  start = end = NULL\n\n\n  # start call first tad\n  if(signs[1] == -1){\n    start = c(start, 1)\n    i = 1\n  }\n  if(signs[1] == 0){\n    start = c(start, 0)\n    end = c(end, 1)\n    start = c(start, 1)\n    i = 1\n  }\n  if(signs[1] == 1){\n    start = c(start, 0)\n    i = 0\n  }\n\n  repeat{\n    if(i == len) break\n    for(j in (i+1):len){\n\n      if(signs[j] == -1 & j != len) next\n      if(signs[j] == -1 & j == len) break\n\n      if(signs[j] == 0){\n        end = c(end, j)\n        start = c(start, j)\n        break\n      }\n\n      if(signs[j] == 1){\n        if(j==len){\n          end = c(end, j)\n          break\n        }\n\n        if(j < len & signs[j+1] != 1) {\n          end = c(end, j)\n          start = c(start, j+1)\n          break\n        }\n\n        if(j < len & signs[j+1] == 1) next\n\n      }\n    }  ## end of for loop\n    i = max(start)\n    if(j == len) break\n  }    ## end of repeat loop\n\n  # final ends\n  if(length(start) > length(end)){\n    end <- c(wb_peaks[end], nn)\n  }else{\n    end <- wb_peaks[end]\n  }\n\n  # final starts\n  if(start[1] == 0){\n    start = c(1, wb_peaks[start[-1]])\n  }else{\n    start = wb_peaks[start]\n  }\n\n  dd = data.frame(\"start\" = start, \"end\" = end)\n  dd = dd[dd$start != dd$end, ]\n  return(dd)\n}\ndef_tad_gmap = cmpfun(def_tad_gmap)\n\n\n\n## using boundary to define segmatation\nfull_seg <- function(bounds){\n  len = length(bounds)\n  return(data.frame('start' = bounds[-len], 'end' = bounds[-1]))\n}\nfull_seg = cmpfun(full_seg)\n\n\n## score function\n## score = difference between TAD area and a predefined area (not whole background)\n## the predifined area: wd bins from diagonal of hic_mat\ntune_score <- function(pp, tads, rnum_bk, tnum_bk){\n\n  # calculate real contact number and total number for within TADs\n  rnum_tad = apply(as.matrix(tads), 1, function(x) sum(pp[x[1]:x[2], x[1]:x[2]]))\n  tnum_tad = apply(as.matrix(tads), 1, function(x) (x[2]-x[1]+1)^2)\n\n  # define the score\n  rnum_tad = sum(rnum_tad)\n  tnum_tad = sum(tnum_tad)\n\n  p1 = rnum_tad/tnum_tad\n  p2 = rnum_bk/tnum_bk\n\n  p0 = (rnum_tad + rnum_bk)/(tnum_tad + tnum_bk)\n  dpScore = (p1 - p2)/sqrt(p0*(1-p0)*(1/tnum_tad + 1/tnum_bk))\n\n  if(p1 == p2) dpScore = 0\n\n\n\n  return(dpScore)\n}\ntune_score = cmpfun(tune_score)\n\n\n\n## including tune t1 and t2 -- given dp and d\ntune_T1T2 <- function(pp, stats, d, dp, rnum_bk, tnum_bk, fcthr, t1thr = 0.5){\n\n  stat_up = stats$up\n  stat_down = stats$down\n  stat_wb = stats$wb\n  pr_fc_wb = stats$pr_fc_wb\n  pr_fc_ud = stats$pr_fc_ud\n  nn = nrow(pp)\n\n  # no local peaks\n  if(all(diff(stat_wb) <=0) || all(diff(stat_wb) >= 0)) return(list('score' = 0, 'tads' = NULL))\n\n  # 75% quantile is too close to 99% quantile\n  if(max(stat_wb)- quantile(stat_wb, 0.75) < 1) return(list('score' = 0, 'tads' = NULL))\n\n  sthr = 0.05\n  sthr0 = round(qnorm(sthr/nn, lower.tail = F), 1)\n\n  # give candidates for t1\n  stat_wb = runmean(stat_wb, 5)\n\n  if(F){\n    cand_t1 <- quantile(stat_wb, seq(t1thr, 1.0, length = 10))\n    if(all(cand_t1 < sthr0)) return(list('score' = 0, 'tads' = NULL))\n\n    cand_t1 = unique(pmax(sthr0, round(cand_t1, 1)))\n\n  }\n  cand_t1 = seq(t1thr, 1.0, length = 10)  # new way\n\n  # define t2 candidates globally\n  tmp = c(stat_up, stat_down)\n  cand_t2 <- quantile(tmp[tmp != 0], seq(0.975, 1.0, length = 10))\n  tmp = qnorm(sthr, lower.tail = F)\n  cand_t2 = unique(pmax(tmp, round(cand_t2, 2)))\n\n\n  len1 = length(cand_t1)\n  len2 = length(cand_t2)\n  score = matrix(0, len1, len2)\n\n  ## define another stats for choosing between two close peaks\n  #stat_alt = cal_stat(pp, max(d-5, floor(d/2)))$wb\n  #stat_alt = cal_stat(pp, max(d-5, floor(d/2)))$pr_fc_wb\n\n  for(i in 1:len1){\n    wb_peaks = localMaxima1(stat_wb, pr_fc_wb, thr = cand_t1[i], fcthr, dp = dp)\n\n    if(is.null(wb_peaks)) {\n      score[i, ] = 0\n      next\n    }\n\n    if(length(wb_peaks) == 0) {\n      score[i, ] = 0\n      next\n    }\n\n    for(j in 1:len2){\n\n      tads <- def_tad_gmap(wb_peaks, stat_up, stat_down, nn, thr = cand_t2[j], pr_fc_ud)\n\n      if(nrow(tads) == 0) {\n        score[i, j] = 0\n      }else{\n        score[i, j] <- tune_score(pp, tads, rnum_bk, tnum_bk)\n      }\n    }\n  }\n\n  if(max(score, na.rm = TRUE) <= 0) return(list('score' = 0, 'tads' = NULL))\n\n  ind = which(score == max(score, na.rm = TRUE), arr.ind=TRUE)[1, ]\n  wb_peaks = localMaxima1(stat_wb, pr_fc_wb, thr = cand_t1[ind[1]], fcthr, dp = dp)\n\n  if(is.null(wb_peaks)) return(list('score' = 0, 'tads' = NULL))\n\n  tads <- def_tad_gmap(wb_peaks, stat_up, stat_down, nn,\n                       thr = cand_t2[ind[2]], pr_fc_ud)\n\n  return(list('tads' = tads, 'score' = max(score), 't1' = round(cand_t1[ind[1]], 3),\n              't2' = round(cand_t2[ind[2]], 3) , 'stats' = stats,\n              'local_peaks' = wb_peaks))\n}\ntune_T1T2 = cmpfun(tune_T1T2)\n\n\n\n\n## tune all parameters -- give candidates of d and dp\ntune_allPara <- function(pp, candD, candDp, rnum_bk, tnum_bk, fcthr, t1thr = 0.5){\n  lend = length(candD)\n  lendp = length(candDp)\n  score = matrix(0, lend, lendp)\n  nn = nrow(pp)\n  sthr = 0.05\n\n  for(i in 1:lend){\n    stats = cal_stat(pp, d = candD[i])\n    if(all(stats$wb <= qnorm(sthr/nn, lower.tail = F))) {\n      score[i, ] = 0\n      next\n    }\n    for(j in 1:lendp){\n      score[i, j] = tune_T1T2(pp, stats, d = candD[i], dp = candDp[j],\n                              rnum_bk, tnum_bk, fcthr, t1thr = t1thr)$score\n    }\n  }\n\n  if(max(score, na.rm = TRUE) <= 0) return(NULL)\n\n  ind = which(score == max(score, na.rm = TRUE), arr.ind = T)[1, ]\n  d = candD[ind[1]]\n  dp = candDp[ind[2]]\n\n  stats = cal_stat(pp, d = d)\n  res = tune_T1T2(pp, stats, d = d, dp = dp, rnum_bk, tnum_bk, fcthr, t1thr = t1thr)\n  res$d = d\n  res$dp = dp\n  return(res)\n\n}\ntune_allPara = cmpfun(tune_allPara)\n\n\n\n## remove redundant domains and add false gaps\ndomain_correction <- function(subTads, pp, rnum_bk, tnum_bk){\n\n  subTads = as.matrix(subTads)\n  bds = sort(unique(as.vector(subTads)))\n\n  ## filter domains with very small contacts\n  subTads = as.matrix(full_seg(bds))\n\n  s_density = round(apply(subTads, 1, function(x) mean(pp[x[1]:x[2], x[1]:x[2]])), 2)\n  tsize = round(apply(subTads, 1, function(x) x[2] - x[1]))\n  nn = nrow(pp)\n\n  calDensity_expect <- function(tsize0){\n    ids = lapply(1:nn, function(x) return(cbind(x, c(max(1, x - tsize0):min(nn, x + tsize0)))))\n    ids = do.call('rbind', ids)\n    return(round(mean(pp[ids]), 2))\n  }\n\n\n  e_density = sapply(tsize, calDensity_expect)\n\n  #tmp = cbind(subTads, s_density, e_density, e_density*1.1)\n  #write.table(tmp, file = 'tmp.txt', row.names = F, col.names = F, quote = F, sep = '\\t')\n  #message(round(rnum_bk/tnum_bk, 2))\n\n\n  ids = which(s_density <= pmax(e_density, rnum_bk/tnum_bk))\n  if(length(ids) > 0) subTads = subTads[-ids, ]\n\n  return(subTads)\n}\ndomain_correction = cmpfun(domain_correction)\n\n\n## remove redundant domains and add false gaps locally\n## dw represents dw up- and down- range of the current domain\ndomain_correction_local <- function(subTads, pp, rnum_bk, tnum_bk, dw = 5){\n\n  subTads = as.matrix(subTads)\n  bds = sort(unique(as.vector(subTads)))\n\n  ## filter domains with very small contacts\n  subTads = as.matrix(full_seg(bds))\n\n  s_density = round(apply(subTads, 1, function(x) mean(pp[x[1]:x[2], x[1]:x[2]])), 2)\n  tsize = round(apply(subTads, 1, function(x) x[2] - x[1]))\n  nn = nrow(pp)\n\n  calDensity_expect_local <- function(tsize0, dw0 = dw){\n    ids = lapply(1:nn, function(x) return(cbind(x, c(max(1, x - dw0 * tsize0):min(nn, x + dw0 * tsize0)))))\n    ids = do.call('rbind', ids)\n    return(round(mean(pp[ids]), 2))\n  }\n\n\n  e_density = sapply(tsize, calDensity_expect_local)\n\n  #tmp = cbind(subTads, s_density, e_density, e_density*1.1)\n  #write.table(tmp, file = 'tmp.txt', row.names = F, col.names = F, quote = F, sep = '\\t')\n  #message(round(rnum_bk/tnum_bk, 2))\n\n\n  ids = which(s_density <= pmax(e_density, rnum_bk/tnum_bk))\n  if(length(ids) > 0) subTads = subTads[-ids, ]\n\n  return(subTads)\n}\ndomain_correction_local = cmpfun(domain_correction_local)\n\n\n\ncall_domain <- function(sub_mat, Max_d, min_d, Max_dp, min_dp, Bg_d, fcthr, hthr = 0.5,\n                        bthr = 200, t1thr = 0.5){\n\n  nn = nrow(sub_mat)\n\n\n  # if the tad is too small (less than 10 bins), do not call subtad\n  if(nn <= 10) return(list(\"tads\" = NULL))\n\n  # do clustering\n  if(nn <= bthr){\n    temp = as.vector(sub_mat[upper.tri(sub_mat, diag=T)])\n    if(length(unique(temp)) < 2) return(list(\"tads\" = NULL))\n\n    class1 = rep(0, length(temp))\n\n    # deal with outliers\n    a3 = quantile(temp, 0.9)\n\n    if(a3 <= 0) return(list(\"tads\" = NULL))\n\n    ids = which(temp >= a3)\n\n    if(length(ids) > 0){\n      class1[ids] = 1\n      temp = temp[-ids]\n      class0 = class1[-ids]\n    }else{\n      class0 = class1\n    }\n\n    if(quantile(temp, 0.9) <= 0) return(list(\"tads\" = NULL))\n\n    if(length(unique(temp)) >= 2){\n      model2 <- Mclust(temp, G = 2, modelNames = 'E')\n\n      if(!is.null(model2)){\n        ind = which.max(model2$parameters$mean)\n        posterior = model2$z[, ind]\n        class0 = ifelse(posterior > hthr, 1, 0)\n        rm(posterior)\n      }\n\n      if(is.null(model2)){ ## not covergent\n        message('Trying using models with different variances')\n        model2 <- Mclust(temp, G = 2, modelNames = 'V')\n        if(!is.null(model2)) {\n          ind = which.max(model2$parameters$mean)\n          posterior = model2$z[, ind]\n          class0 = ifelse(posterior > hthr, 1, 0)\n          rm( posterior)\n        }else{\n          message('No models can be fitted, using 75% quantile as cutoff')\n          class0 = ifelse(temp > quantile(temp, 0.75), 1, 0)\n        }\n      }\n\n\n      # just in case:\n      if(length(unique(class0)) == 1 )  class0 = ifelse(temp > quantile(temp, 0.75), 1, 0)\n      rm(temp, model2)\n\n    }\n\n\n    pp = matrix(0L, nn, nn)\n\n    if(length(ids) > 0) {\n      class1[-ids] = class0\n      pp[upper.tri(pp, diag=T)] = class1\n    }else{\n      pp[upper.tri(pp, diag=T)] = class0\n    }\n\n    pp = pp + t(pp) - diag(diag(pp))\n    rm(class0, class1)\n  }\n\n  if(nn > bthr){\n    ## if the hic-matrix is too large, we assume two loci with distance larger than\n    ## say 1000 bins have no interactions. Data from this part will not be used for\n    ## constructing the mixture models\n    if(all(class(sub_mat) != \"data.frame\")) {\n      mat = data.frame(sub_mat)\n    }\n    mat = as.list(mat)  ## for faster subsetting\n\n    colIDs =  sapply(1:nn, function(x) return(c(x : min(nn, x + bthr))))\n    len = sapply(colIDs, length)\n\n    getData <- function(x){\n      return(mat[[x]][colIDs[[x]]])\n    }\n    temp = unlist(sapply(1:nn, getData))\n    rm(mat)\n\n\n\n    rowIDs = rep(1:nn, len)\n    colIDs = unlist(colIDs)\n\n    partialIDs = cbind(rowIDs, colIDs)\n    rm(rowIDs, colIDs)\n\n    # deal with outliers\n    class1 = rep(0, length(temp))\n\n    # deal with outliers\n\n    a3 = (quantile(temp, 0.975) )\n    a1 = max(quantile(temp, 0.025), 0)\n\n    id1 = which(temp <= a1)\n    id3 = which(temp >= a3)\n    ids = NULL\n\n    if(length(id3) > 0){\n      class1[id3] = 1\n      ids = c(id1, id3)\n      temp = temp[-ids]\n      class0 = class1[-ids]\n    }else{\n      if(length(id1) > 0){\n        ids = id1\n        temp = temp[-ids]\n        class0 = class1[-ids]\n      }else{\n        class0 = class1\n      }\n    }\n\n\n    if(length(unique(temp)) >= 2){\n      model2 <- Mclust(temp, G = 2, modelNames = 'E')\n\n      if(!is.null(model2)){\n        ind = which.max(model2$parameters$mean)\n        posterior = model2$z[, ind]\n        class0 = ifelse(posterior > hthr, 1, 0)\n        rm(posterior)\n      }\n\n      if(is.null(model2)){ ## not covergent\n        message('Trying using models with different variances')\n        model2 <- Mclust(temp, G = 2, modelNames = 'V')\n        if(!is.null(model2)) {\n          ind = which.max(model2$parameters$mean)\n          posterior = model2$z[, ind]\n          class0 = ifelse(posterior > hthr, 1, 0)\n          rm(posterior)\n        }else{\n          message('No models can be fitted, using 75% quantile as cutoff')\n          class0 = ifelse(temp > quantile(temp, 0.75), 1, 0)\n        }\n      }\n\n\n      # just in case:\n      if(length(unique(class0)) == 1 )  class0 = ifelse(temp > quantile(temp, 0.75), 1, 0)\n      rm(temp, model2)\n    }\n\n\n    pp = matrix(0L, nn, nn)\n\n    if(length(ids) > 0) {\n      class1[-ids] = class0\n      pp[partialIDs] = class1\n    }else{\n      pp[partialIDs] = class0\n    }\n\n    pp = pp + t(pp) - diag(diag(pp))\n    rm(class0, partialIDs)\n  }\n\n  ##\n  diag(pp) <- 0\n\n  # define candidates for d and dp\n  #candD = seq(min_d, Max_d, by = min_d)\n  candD = seq(min_d, Max_d, by = min_d)\n\n  candDp = seq(min_dp, Max_dp, by = min_dp)\n\n  # define the background\n  if(Bg_d >= nn){\n\n    rnum_bk <- sum(pp)\n    tnum_bk <- length(pp)\n\n    rnum_bk0 = sum(sub_mat)\n\n  }else{\n    if(Bg_d > bthr) Bg_d = bthr\n    idBg = sapply(1:nn, function(x) return(cbind(x, c(max(1, x - Bg_d):min(nn, x + Bg_d)))))\n    idBg = do.call('rbind', idBg)\n    temp = pp[idBg]\n    rnum_bk <- sum(temp)\n    tnum_bk <- length(temp)\n\n    temp0 = sub_mat[idBg]\n    rnum_bk0 = sum(temp0)\n  }\n\n  if(rnum_bk >= 0.95 * tnum_bk || rnum_bk < 1/sqrt(tnum_bk) * tnum_bk) return(list(\"tads\" = NULL))\n\n  res = tune_allPara(pp, candD, candDp, rnum_bk, tnum_bk, fcthr, t1thr)\n  subTads = res$tads\n\n\n  if(!is.null(subTads)) res$tads = domain_correction_local(subTads, pp, rnum_bk, tnum_bk)\n  #if(!is.null(subTads)) res$tads = domain_correction(subTads, sub_mat, rnum_bk0, tnum_bk)\n\n  return(res)\n}\ncall_domain = cmpfun(call_domain)\n\n\n\n\n\n#' Detect hierarchical choromotin domains by GMAP\n#' @param  hic_mat n by n matrix, n is the number of bins. Or hic_mat could by 3 columns\n#' matrix or data.frame with columns: bin1, bin2, counts, in which bin1 and bin2, from 1 to m, are the bin\n#' index of a hic contact\n#' @param  resl The resolution (bin size), default 10kb\n#' @param  min_d The minimum d (d: window size), default 25\n#' @param  Max_d The maximum d (d: window size), default 2mb (or 200 bins)\n#' @param min_dp The minmum dp (dp: lower bound of tad size), defalt 5\n#' @param Max_dp The maximum dp (dp: lower bound of tad size), defalt 10\n#' @param Bg_d The size of the background domain, dalfault 2mb or 200bins\n#' @param hthr The lower bound cutoff for posterior probability, default 0.5 for TADs,\n#'        0.9 for subTADs\n#' @param bthr Threshold, above which a locus' contact is ignored , default 1000, means\n#'        for each locus, only consider contacts that within 1000 bins distance away of it\n#' @param t1thr Lower bound for t1 for calling TAD, default 0.5 quantile of test statistics\n#'        for TADs, 0.9 for subTADs\n#' @param fcthr Lower bound quantile for fold change of proportion of 1 between\n#'        intra and inter domains, default 0.9\n#' @param logt Do log-transformation or not, default TRUE\n#' @param dom_order Maximum level of hierarchical structures, default 2 (call TADs and subTADs)\n#'         (if all between-within p-value < sthr (after bonferoni correction), stop call TAD or subTAD)\n#'   Max_d, Max_dp, Bg_d should be specified in number of bins and change with resloution\n#' @return A list includes following elements:\n#' \\item{tads}{A data frame with columns start, end indicates the start and end coordinates of each domain, respectively}\n#' \\item{hierTads}{A data frame with columns start, end, dom_order, where dom_order indicates the hierarchical status of a domain, 1 indicates tads, 2 indicates subtads, and so on}\n#' \\item{params}{A data frame gives the final parameters for calling TADs}\n#' @rdname rGMAP\n#' @export\nrGMAP <- function(hic_mat, resl = 10*10^3, logt = T, dom_order = 2,\n                  min_d = 50, Max_d = 200, min_dp = 5, Max_dp = 10,\n                  Bg_d = 200, hthr = 0.9,\n                  bthr = 400, t1thr = 0.75, fcthr = 0.9){\n\n  if(ncol(hic_mat) == 3){\n    names(hic_mat) = c('n1', 'n2', 'counts')\n\n\n    hic_mat = sparseMatrix(i = hic_mat$n1, j = hic_mat$n2, x=hic_mat$counts,\n                           symmetric = T )\n  }\n\n  hic_mat = as.matrix(hic_mat)\n  hic_mat[is.na(hic_mat)] = 0L\n  hic_mat = round(hic_mat)\n  options(scipen = 10)\n\n\n  # remove first k rows and columns if the first k by k submatrix is zero matrix\n  k = 0\n  for(i in 1:nrow(hic_mat)){\n    if(any(hic_mat[i, ] != 0)) {\n      k = i - 1\n      break\n    }\n  }\n  if(k > 0) {\n    hic_mat = hic_mat[-(1:k), -(1:k)]\n    #message(paste(\">>>> remove first \", k, \" bins whose counts are all zero\"))\n  }\n  nn = nrow(hic_mat)\n\n  ## adjust distance effect\n\n\n\n  ## do logtransformation\n  if(logt){\n    hic_mat[which(hic_mat < 0, arr.ind = T)] = 0\n    hic_mat = log(hic_mat + 1)\n  }\n\n\n  message(\">>>> call TADs...\")\n  res = call_domain(hic_mat, Max_d, min_d, Max_dp, min_dp, Bg_d, fcthr, hthr,\n                    bthr, t1thr)\n  tads = res$tads\n  if(is.null(tads)) {\n    message(\">>> No tads: probably because Bg_d is specified too small or bthr too big!\")\n    message(\">>> first try: decrease bthr\")\n    res = call_domain(hic_mat, Max_d, min_d, Max_dp, min_dp, Bg_d, fcthr, hthr,\n                      floor(bthr*0.8), t1thr)\n    tads = res$tads\n    if(is.null(tads)){\n      message(\">>> second try: incease Bg_d\")\n      res = call_domain(hic_mat, Max_d, min_d, Max_dp, min_dp, Bg_d * 2 ,\n                        fcthr, hthr,\n                        bthr, t1thr)\n      tads = res$tads\n    }\n    if(is.null(tads)){\n      message(\">>> third try: decrease bthr and double Bg_d\")\n      res = call_domain(hic_mat, Max_d, min_d, Max_dp, min_dp, Bg_d *2,\n                        fcthr, hthr,\n                        floor(bthr*0.8), t1thr)\n      tads = res$tads\n    }\n\n    if(is.null(tads)){\n      message(\">>> Give up, No tads detected!\")\n      return(list(\"tads\" = NULL, 'hierTads' = NULL))\n    }\n\n  }\n  params = data.frame('score' = round(res$score, 1), 'd' = res$d, 'dp' = res$dp, 't1' = res$t1, 't2' = res$t2)\n\n  message(paste(c('score', 'd =', 'dp =', 't1 =', 't2 ='), unlist(params),  collapse = \", \"))\n\n  ## call hierarchical structure\n\n  hierTads = list()\n  if(dom_order > 1){\n    ll = 1\n    parenTads = tads\n    if(is.null(tads)) return(list(\"tads\" = NULL, 'hierTads' = NULL))\n\n\n    hierTads[[ll]] = data.frame(tads)\n\n    while(ll < dom_order){\n      tempTads = list()\n      ll = ll + 1\n      for(i in 1:nrow(parenTads)){\n\n        Sbin = parenTads[i, 1]\n        Ebin = parenTads[i, 2]\n        len = Ebin - Sbin + 1\n        if(len <= min(40, floor(500*1000/resl))) next\n\n        message(paste(\">>>> call sub-domains for \", i, \"th\",\" domain of order \", ll-1,\n                      \"...\", sep = \"\"))\n        message(paste(\"start from bin \", parenTads[i, 1], \" to bin \", parenTads[i, 2], sep = \"\"))\n\n\n        md = min(200*1000/resl, 15)\n        Md = min(5 * md, floor(len/3))\n        Md = max(md, Md)\n\n        mdp = min_dp\n        Mdp = Max_dp\n\n        tmp0 <-  call_domain(hic_mat[Sbin:Ebin, Sbin:Ebin], Md, md, Mdp, mdp,\n                             Bg_d = len, fcthr = max(fcthr, 0.925), hthr = max(hthr, 0.99),  len,\n                             t1thr = max(0.925, t1thr))\n\n        if(is.null(tmp0$tads)){\n          message(paste('>>> no sub-TADs found!'))\n          next\n        }\n\n        tempTads[[i]] = tmp0$tads + Sbin - 1\n        params0 = c(tmp0$d, tmp0$dp, tmp0$t1, tmp0$t2)\n\n        message(paste(c('d =', 'dp =', 't1 =', 't2 ='), params0,  collapse = \", \"))\n\n      }\n\n      ## do not go to next step if no subTads are called from current level\n      if(length(tempTads) == 0) break\n\n      parenTads = data.frame(do.call(\"rbind\", tempTads), row.names = NULL)\n\n      hierTads[[ll]] = parenTads\n\n    }\n    rm(hic_mat)\n  }\n\n  message(\">>>> Domain calling all done!\")\n\n  tads = data.frame((tads+k) * resl - floor(resl/2))\n\n  if(length(hierTads) == 0) {\n    hierTads = tads\n    hierTads$dom_order = 1\n  }else{\n    hierTads = lapply(hierTads, function(x) (x + k) * resl - floor(resl/2))\n\n    dlens = sapply(hierTads, nrow)\n\n    hierTads = do.call('rbind', hierTads)\n\n    hierTads$dom_order = rep(1:length(dlens), dlens)\n  }\n\n\n  row.names(hierTads) = NULL\n  return(list('tads' = tads, 'hierTads' = hierTads, 'params' = params))\n\n}\n\nrGMAP = cmpfun(rGMAP)\n\n\n\n\n\n\n## call tad by method from HiCseg package\n#' @export\ntad_hicseg <- function(hic_mat, Kmax=12, distr = 'G', resl=1, model = 'D'){\n  if(ncol(hic_mat) == 3){\n    names(hic_mat) = c('n1', 'n2', 'counts')\n\n    if(distr == 'P') hic_mat$counts = round(hic_mat$counts)\n    hic_mat = sparseMatrix(i = hic_mat$n1, j = hic_mat$n2, x=hic_mat$counts,\n                           symmetric = T )\n  }\n\n  hic_mat = as.matrix(hic_mat)\n  hic_mat[is.na(hic_mat)] = 0L\n  options(scipen = 10)\n\n  n = nrow(hic_mat)\n  res = HiCseg_linkC_R(n, Kmax, distr, hic_mat, model = model)\n  ind = max(1, which.max(res$J))\n  chg_points = res$t_est_mat[ind, 1:ind]\n  chg_points = c(1, chg_points)\n  tad_seg = full_seg(chg_points) * resl\n  return(tad_seg)\n}\n\n\n\n\n\n## generate simulated hic_mat and true tads\n#' @export\ndata_simu <- function(stype = 'poisson', nratio = 2.5, mu0 = 20, resl = 1){\n\n  if(stype == 'poisson-dist'){\n    ## TADs with gap and Hier\n    tbins = 1000  ## total bins\n\n    bounds = c(1, 120, 160, 215, 355, 440, 530, 705, 765, 850, 950, 1000)\n    bounds = sort(unique(bounds))\n    #mu0 = 5\n    ntad = length(bounds) - 1\n\n\n    n = max(bounds)\n    hic_mat  = matrix(0, n, n)\n    hic_mat = as.data.table(as.data.frame(hic_mat))\n\n    generateSparse_dat <- function(n1, mu1){\n      df = data.table('id1' = rep(1:(n1), (n1):1),\n                      'id2' = do.call('c', sapply(1:(n1), function(x) (x):n1)))\n      df[, 'dist' := (id2 - id1)]\n      df[, dist := ifelse(dist == 0, 0.9, dist)]\n      df[, 'N' := rpois(1, mu1  * dist^(-1)), by = list(id1, id2)]\n\n      return(df)\n    }\n\n    df = generateSparse_dat(n, mu0)\n\n    for(k in 1:nrow(df)) set(hic_mat, i = as.integer(df$id1[k]),\n                             j = as.integer(df$id2[k]), value = df$N[k])\n    for(k in 1:nrow(df)) set(hic_mat, i = as.integer(df$id2[k]),\n                             j = as.integer(df$id1[k]), value = df$N[k])\n\n    hic_mat = as.matrix(hic_mat)\n\n\n    modify_dat <- function(hic_mat, bounds, skip_ind = 0, mu = 5){\n      ntad = length(bounds) - 1\n      sizes = diff(bounds) + 1\n      for(i in 1:ntad){\n        if(i %in% skip_ind) next\n        tn = sizes[i]\n        #t_mu = mu * (1 + min(sizes)/tn)\n        t_mu = mu\n        df = generateSparse_dat(tn, t_mu)\n        thic_mat  = matrix(0, tn, tn)\n        thic_mat = as.data.table(as.data.frame(thic_mat))\n        for(k in 1:nrow(df)) set(thic_mat, i = as.integer(df$id1[k]),\n                                 j = as.integer(df$id2[k]), value = df$N[k])\n        for(k in 1:nrow(df)) set(thic_mat, i = as.integer(df$id2[k]),\n                                 j = as.integer(df$id1[k]), value = df$N[k])\n        thic_mat = as.matrix(thic_mat)\n        start = bounds[i]\n        end = bounds[i+1]\n        hic_mat[start:end, start:end] = thic_mat\n      }\n      return(hic_mat)\n\n    }\n\n    ## add TADs\n    hic_mat = modify_dat(hic_mat, bounds, skip_ind = c(5, 7), mu0 * nratio)\n\n\n    tads_true <- data.frame('start' = bounds[1:ntad], 'end' = bounds[2:(ntad + 1)])\n    tads_true <- tads_true[-c(5, 7), ] * resl ## a gap\n\n  }\n\n  if(stype == 'poisson-dist-hier'){\n    ## TADs with gap and Hier\n    tbins = 1000  ## total bins\n\n    bounds = c(1, 120, 160, 215, 355, 440, 530, 705, 765, 850, 950, 1000)\n    bounds = sort(unique(bounds))\n    #mu0 = 5\n    ntad = length(bounds) - 1\n\n\n    n = max(bounds)\n    hic_mat  = matrix(0, n, n)\n    hic_mat = as.data.table(as.data.frame(hic_mat))\n\n    generateSparse_dat <- function(n1, mu1){\n      df = data.table('id1' = rep(1:(n1), (n1):1),\n                      'id2' = do.call('c', sapply(1:(n1), function(x) (x):n1)))\n      df[, 'dist' := (id2 - id1)]\n      df[, dist := ifelse(dist == 0, 0.9, dist)]\n      df[, 'N' := rpois(1, mu1  * dist^(-1)), by = list(id1, id2)]\n\n      return(df)\n    }\n\n    df = generateSparse_dat(n, mu0)\n\n    for(k in 1:nrow(df)) set(hic_mat, i = as.integer(df$id1[k]),\n                             j = as.integer(df$id2[k]), value = df$N[k])\n    for(k in 1:nrow(df)) set(hic_mat, i = as.integer(df$id2[k]),\n                             j = as.integer(df$id1[k]), value = df$N[k])\n\n    hic_mat = as.matrix(hic_mat)\n\n\n    modify_dat <- function(hic_mat, bounds, skip_ind = 0, mu = 5){\n      ntad = length(bounds) - 1\n      sizes = diff(bounds) + 1\n      for(i in 1:ntad){\n        if(i == skip_ind) next\n        tn = sizes[i]\n        #t_mu = mu * (1 + min(sizes)/tn)\n        t_mu = mu\n        df = generateSparse_dat(tn, t_mu)\n        thic_mat  = matrix(0, tn, tn)\n        thic_mat = as.data.table(as.data.frame(thic_mat))\n        for(k in 1:nrow(df)) set(thic_mat, i = as.integer(df$id1[k]),\n                                 j = as.integer(df$id2[k]), value = df$N[k])\n        for(k in 1:nrow(df)) set(thic_mat, i = as.integer(df$id2[k]),\n                                 j = as.integer(df$id1[k]), value = df$N[k])\n        thic_mat = as.matrix(thic_mat)\n        start = bounds[i]\n        end = bounds[i+1]\n        hic_mat[start:end, start:end] = thic_mat\n      }\n      return(hic_mat)\n\n    }\n\n    ## add TADs\n    hic_mat = modify_dat(hic_mat, bounds, skip_ind = 5, mu0 * nratio)\n\n\n\n    # generate subTADs\n    start = 530\n    end = 705\n\n    sbounds = c(start, start + 50, start + 130, end)\n\n    hic_mat = modify_dat(hic_mat, sbounds, skip_ind = 0, mu = mu0 * nratio * nratio)\n\n\n    tads_true <- data.frame('start' = bounds[1:ntad],\n                            'end' = bounds[2:(ntad + 1)]) * resl\n    tads_true = tads_true[-5, ]  ## a gap\n\n    sub_tads <- data.frame('start' = sbounds[1:3],\n                           'end' = sbounds[2:4]) * resl\n\n    hierTads = rbind(tads_true, sub_tads)\n    hierTads$dom_order = c(rep(1, nrow(tads_true)), rep(2, nrow(sub_tads)))\n\n  }\n\n  if(stype == 'poisson-dist-hier2'){\n    ## TADs with gap and Hier\n    tbins = 1000  ## total bins\n\n    bounds = c(1, 120, 160, 215, 355, 440, 530, 705, 765, 850, 950, 1000)\n    bounds = sort(unique(bounds))\n    #mu0 = 5\n    ntad = length(bounds) - 1\n\n\n    n = max(bounds)\n    hic_mat  = matrix(0, n, n)\n    hic_mat = as.data.table(as.data.frame(hic_mat))\n\n    generateSparse_dat <- function(n1, mu1){\n      df = data.table('id1' = rep(1:(n1), (n1):1),\n                      'id2' = do.call('c', sapply(1:(n1), function(x) (x):n1)))\n      df[, 'dist' := (id2 - id1)]\n      df[, dist := ifelse(dist == 0, 0.9, dist)]\n      df[, 'N' := rpois(1, mu1  * dist^(-1)), by = list(id1, id2)]\n\n      return(df)\n    }\n\n    df = generateSparse_dat(n, mu0)\n\n    for(k in 1:nrow(df)) set(hic_mat, i = as.integer(df$id1[k]),\n                             j = as.integer(df$id2[k]), value = df$N[k])\n    for(k in 1:nrow(df)) set(hic_mat, i = as.integer(df$id2[k]),\n                             j = as.integer(df$id1[k]), value = df$N[k])\n\n    hic_mat = as.matrix(hic_mat)\n\n\n    modify_dat <- function(hic_mat, bounds, skip_ind = 0, mu = 5){\n      ntad = length(bounds) - 1\n      sizes = diff(bounds) + 1\n      for(i in 1:ntad){\n        if(i == skip_ind) next\n        tn = sizes[i]\n        #t_mu = mu * (1 + min(sizes)/tn)\n        t_mu = mu\n        df = generateSparse_dat(tn, t_mu)\n        thic_mat  = matrix(0, tn, tn)\n        thic_mat = as.data.table(as.data.frame(thic_mat))\n        for(k in 1:nrow(df)) set(thic_mat, i = as.integer(df$id1[k]),\n                                 j = as.integer(df$id2[k]), value = df$N[k])\n        for(k in 1:nrow(df)) set(thic_mat, i = as.integer(df$id2[k]),\n                                 j = as.integer(df$id1[k]), value = df$N[k])\n        thic_mat = as.matrix(thic_mat)\n        start = bounds[i]\n        end = bounds[i+1]\n        hic_mat[start:end, start:end] = thic_mat\n      }\n      return(hic_mat)\n\n    }\n\n    ## add TADs\n    hic_mat = modify_dat(hic_mat, bounds, skip_ind = 5, mu0 * nratio)\n\n\n\n    # generate subTADs\n    start = 530\n    end = 705\n\n    sbounds = c(start, start + 25, end)\n\n    hic_mat = modify_dat(hic_mat, sbounds, skip_ind = 0, mu = mu0 * nratio * nratio)\n\n\n    tads_true <- data.frame('start' = bounds[1:ntad],\n                            'end' = bounds[2:(ntad + 1)]) * resl\n    tads_true = tads_true[-5, ]  ## a gap\n\n    sub_tads <- data.frame('start' = sbounds[1:2],\n                           'end' = sbounds[2:3]) * resl\n\n    hierTads = rbind(tads_true, sub_tads)\n    hierTads$dom_order = c(rep(1, nrow(tads_true)), rep(2, nrow(sub_tads)))\n\n  }\n\n\n  if(stype == 'nb-dist-hier'){\n    ## TADs with gap and Hier\n    tbins = 1000  ## total bins\n\n    bounds = c(1, 120, 160, 215, 355, 440, 530, 705, 765, 850, 950, 1000)\n    bounds = sort(unique(bounds))\n    #mu0 = 5\n    ntad = length(bounds) - 1\n\n\n    n = max(bounds)\n    hic_mat  = matrix(0, n, n)\n    hic_mat = as.data.table(as.data.frame(hic_mat))\n\n    phi0 = 4\n    generateSparse_dat <- function(n1, mu1){\n      df = data.table('id1' = rep(1:(n1), (n1):1),\n                      'id2' = do.call('c', sapply(1:(n1), function(x) (x):n1)))\n      df[, 'dist' := (id2 - id1)]\n      df[, dist := ifelse(dist == 0, 0.9, dist)]\n      df[, 'N' := rnbinom(1, mu = mu1  * dist^(-1), size = phi0 * mu1  * dist^(-1)), by = list(id1, id2)]\n\n      return(df)\n    }\n\n    df = generateSparse_dat(n, mu0)\n\n    for(k in 1:nrow(df)) set(hic_mat, i = as.integer(df$id1[k]),\n                             j = as.integer(df$id2[k]), value = df$N[k])\n    for(k in 1:nrow(df)) set(hic_mat, i = as.integer(df$id2[k]),\n                             j = as.integer(df$id1[k]), value = df$N[k])\n\n    hic_mat = as.matrix(hic_mat)\n\n\n    modify_dat <- function(hic_mat, bounds, skip_ind = 0, mu = 5){\n      ntad = length(bounds) - 1\n      sizes = diff(bounds) + 1\n      for(i in 1:ntad){\n        if(i == skip_ind) next\n        tn = sizes[i]\n        #t_mu = mu * (1 + min(sizes)/tn)\n        t_mu = mu\n        df = generateSparse_dat(tn, t_mu)\n        thic_mat  = matrix(0, tn, tn)\n        thic_mat = as.data.table(as.data.frame(thic_mat))\n        for(k in 1:nrow(df)) set(thic_mat, i = as.integer(df$id1[k]),\n                                 j = as.integer(df$id2[k]), value = df$N[k])\n        for(k in 1:nrow(df)) set(thic_mat, i = as.integer(df$id2[k]),\n                                 j = as.integer(df$id1[k]), value = df$N[k])\n        thic_mat = as.matrix(thic_mat)\n        start = bounds[i]\n        end = bounds[i+1]\n        hic_mat[start:end, start:end] = thic_mat\n      }\n      return(hic_mat)\n\n    }\n\n    ## add TADs\n    hic_mat = modify_dat(hic_mat, bounds, skip_ind = 5, mu0 * nratio)\n\n\n\n    # generate subTADs\n    start = 530\n    end = 705\n\n    sbounds = c(start, start + 50, start + 130, end)\n\n    hic_mat = modify_dat(hic_mat, sbounds, skip_ind = 0, mu = mu0 * nratio * nratio)\n\n\n    tads_true <- data.frame('start' = bounds[1:ntad],\n                            'end' = bounds[2:(ntad + 1)]) * resl\n    tads_true <- tads_true[-5, ]  ## a gap\n\n    sub_tads <- data.frame('start' = sbounds[1:3],\n                           'end' = sbounds[2:4]) * resl\n\n    hierTads <- rbind(tads_true, sub_tads)\n    hierTads$dom_order = c(rep(1, nrow(tads_true)), rep(2, nrow(sub_tads)))\n\n  }\n\n  if(stype == 'nb-dist'){\n    ## TADs with gap and Hier\n    tbins = 1000  ## total bins\n\n    bounds = c(1, 120, 160, 215, 355, 440, 530, 705, 765, 850, 950, 1000)\n    bounds = sort(unique(bounds))\n    #mu0 = 5\n    ntad = length(bounds) - 1\n\n\n    n = max(bounds)\n    hic_mat  = matrix(0, n, n)\n    hic_mat = as.data.table(as.data.frame(hic_mat))\n\n    phi0 = 4\n    generateSparse_dat <- function(n1, mu1){\n      df = data.table('id1' = rep(1:(n1), (n1):1),\n                      'id2' = do.call('c', sapply(1:(n1), function(x) (x):n1)))\n      df[, 'dist' := (id2 - id1)]\n      df[, dist := ifelse(dist == 0, 0.9, dist)]\n      df[, 'N' := rnbinom(1, mu = mu1  * dist^(-1), size = phi0 * mu1  * dist^(-1)), by = list(id1, id2)]\n\n      return(df)\n    }\n\n    df = generateSparse_dat(n, mu0)\n\n    for(k in 1:nrow(df)) set(hic_mat, i = as.integer(df$id1[k]),\n                             j = as.integer(df$id2[k]), value = df$N[k])\n    for(k in 1:nrow(df)) set(hic_mat, i = as.integer(df$id2[k]),\n                             j = as.integer(df$id1[k]), value = df$N[k])\n\n    hic_mat = as.matrix(hic_mat)\n\n\n    modify_dat <- function(hic_mat, bounds, skip_ind = 0, mu = 5){\n      ntad = length(bounds) - 1\n      sizes = diff(bounds) + 1\n      for(i in 1:ntad){\n        if(i %in% skip_ind) next\n        tn = sizes[i]\n        #t_mu = mu * (1 + min(sizes)/tn)\n        t_mu = mu\n        df = generateSparse_dat(tn, t_mu)\n        thic_mat  = matrix(0, tn, tn)\n        thic_mat = as.data.table(as.data.frame(thic_mat))\n        for(k in 1:nrow(df)) set(thic_mat, i = as.integer(df$id1[k]),\n                                 j = as.integer(df$id2[k]), value = df$N[k])\n        for(k in 1:nrow(df)) set(thic_mat, i = as.integer(df$id2[k]),\n                                 j = as.integer(df$id1[k]), value = df$N[k])\n        thic_mat = as.matrix(thic_mat)\n        start = bounds[i]\n        end = bounds[i+1]\n        hic_mat[start:end, start:end] = thic_mat\n      }\n      return(hic_mat)\n\n    }\n\n    ## add TADs\n    hic_mat = modify_dat(hic_mat, bounds, skip_ind = c(5, 7), mu0 * nratio)\n\n\n    tads_true <- data.frame('start' = bounds[1:ntad],\n                            'end' = bounds[2:(ntad + 1)]) * resl\n    tads_true <- tads_true[-c(5, 7), ]  ## a gap\n\n\n  }\n\n  if(!grepl(stype, pattern = 'hier'))  {\n    hierTads = tads_true\n    hierTads$dom_order = 1\n  }\n\n  row.names(tads_true) = row.names(hierTads) = NULL\n  return(list(\"hic_mat\" = hic_mat, \"tads_true\" = tads_true, 'hierTads' = hierTads))\n}\ndata_simu = cmpfun(data_simu)\n",
    "created" : 1485374285883.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "776|57|933|0|\n944|75|964|0|\n972|75|1372|0|\n",
    "hash" : "1415089056",
    "id" : "1894892B",
    "lastKnownWriteTime" : 1507748986,
    "last_content_update" : 1507748987012,
    "path" : "/mnt/isilon/cbmi/tan_lab/yuw1/R-work-dir/TAD_calling/rGMAP/R/rGMAP1.2_source.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}